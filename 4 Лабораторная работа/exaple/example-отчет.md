МИНИСТЕРСТВО науки и высшего ОБРАЗОВАНИЯ РОссИЙСКОЙ ФЕДЕРАЦИИ
 
ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ
УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
«МОСКОВСКИЙ АВИАЦИОННЫЙ ИНСТИТУТ
 (национальный исследовательский университет)»
 

 
Факультет №3 «Системы управления, информатика и электроэнергетика»
Кафедра № 304 «Вычислительные машины, системы и сети»
 
 
 
 
 
Информатика
 
Отчет по лабораторной работе № 3
Вариант 5
 
 
 
 					Выполнили студенты группы: Рыбин.Т.В и Скынтей.М.В
Проверили: Дмитриева Е. А. и Перегудов Е. В.


Оглавление
Задание	3
Блок схема алгоритма	4
Код программы	7
Код программы	11
Тесты	16
Вывод	19

Задание























Блок схема алгоритма 

































































Код программы 
Вариант I
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>



const int SIZE =  5;  // количество элементов в массиве (константа)


int main()
{



   int arr[SIZE];

   int i;           // переменная-итератор основного цикла
   int j;           // переменная-итератор внутреннего цикла
   int choice;      // переменная для хранения выбора режима работы
   int A;           // искомое значение для поиска
   int INC_A;       // позиция найденного элемента в массиве
   int sum;         // накопитель суммы элементов
   int min_nechet;  // наименьшее нечетное значение
   int sort_pr;     // буферная переменная для обмена элементов


   // Установка начального значения для генерации псевдослучайных чисел
   srand(time(NULL));
  
   printf("────────── Working with one-dimensional array ──────────\n\n");
  
   // Определение метода заполнения массива данными
   printf("Specify array filling method:\n");
   printf("[1] Manual keyboard input\n");
   printf("[2] Random value generation\n");
   printf("Enter number: ");
   scanf("%d", &choice);
  
   // Процесс заполнения массива
   if (choice == 1)
   {
       // Режим ручного ввода значений
       printf("\nEnter %d numbers:\n", SIZE);
       for (i = 0; i < SIZE; i++)
       {
           printf("Number %d: ", i + 1); // i+1 для удобства пользователя (нумерация с единицы)
           scanf("%d", &arr[i]); // сохранение введенного значения в ячейку массива
       }
       printf("\n");
       // Отображение введенных данных
       printf("Array address: %p\n", arr);
       printf("Original array: \n");
       for (i = 0; i < SIZE; i++)
       {
           printf("arr[%d] = %d, address: %p\n", i, arr[i], &arr[i]); // вывод значения и адреса каждого элемента
       }
       printf("\n");
   }
   else
   {
       // Режим автоматической генерации
       printf("Generating random numbers.......\n");
       for (i = 0; i < SIZE; i++)
       {
           arr[i] = rand() % 100;  // получение случайного числа в диапазоне 0-99
       }
       // Отображение сгенерированных значений
       printf("Array address: %p\n", arr);
       printf("\nOriginal array: ");
       for (i = 0; i < SIZE; i++)
       {
           printf("arr[%d] = %d, address: %p\n", i, arr[i], &arr[i]); // вывод значения и адреса каждого элемента
       }
   }
  
  
   // Этап отображения исходных данных завершен




   // Шаг 1: Получение искомого значения
   printf("\nEnter number A: ");
   scanf("%d", &A);
  
   // Процесс поиска числа A в массиве
   INC_A = -1;  // установка начального значения (маркер отсутствия)
   for (i = 0; i < SIZE; i++)
   {
       if (arr[i] == A)
       {
           INC_A = i;  // фиксация индекса найденного элемента
           break;      // досрочное завершение цикла при успешном поиске
       }
   }
  
   // Шаг 2: Анализ результата поиска и дальнейшие действия
   if (INC_A != -1)
   {
       printf("Number %d found at position %d\n", A, INC_A);
      
       // Вычисление суммы элементов, расположенных после найденного
       sum = 0;
       for (i = INC_A + 1; i < SIZE; i++) // итерация с элемента, следующего за найденным
       {
           sum += arr[i];
       }
       printf("Sum of elements after found A: %d\n", sum);
   }
   else
   {
       printf("Number %d not found in array\n", A);
      
       // Определение минимального нечетного элемента
       char flag = 0; // индикатор наличия нечетных чисел в массиве
       min_nechet = 1000000;
       for (i = 0; i < SIZE; i++)
       {
           if (arr[i] % 2 != 0) // определение нечетности через остаток деления
           { 
               if (arr[i] < min_nechet) // сравнение с текущим минимумом
               {
                   min_nechet = arr[i]; // обновление минимального значения
                   flag = 1; // активация флага при обнаружении нечетного числа
               }
           }
       }
      
       // Проверка результата поиска нечетных элементов
       if (flag == 1) 
       {
           printf("Minimum odd element: %d\n", min_nechet);   
       }
       else
       {
           printf("No odd elements\n");
       }
   }
  
   // Шаг 3: Сортировка элементов массива по возрастанию (алгоритм "пузырька")
   for (i = 0; i < SIZE - 1; i++)
   {
       for (j = 0; j < SIZE - i - 1; j++)
       {
           if (arr[j] > arr[j + 1])
           {
               // Обмен значениями между соседними элементами
               sort_pr = arr[j];
               arr[j] = arr[j + 1];
               arr[j + 1] = sort_pr;
           }
       }
   }
   printf("\n");
   // Отображение упорядоченного массива
   printf("Array address: %p\n", arr); // вывод начального адреса массива
   printf("Sorted array: \n");
   for (i = 0; i < SIZE; i++)
   {
       printf("arr[%d] = %d, address: %p\n", i, arr[i], &arr[i]); // вывод значения и адреса каждого элемента
   }
   printf("\n");
  
   return 0;
}





Код программы 
Вариант II
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <windows.h>


#define SIZE 5  // определение размерности массива (макрос)


int main()
{
   // настройка кодировки консоли для корректного отображения
   SetConsoleOutputCP(65001); 
   SetConsoleCP(65001);


   int arr[SIZE];
   int i, j, choice, A, INC_A, sum, min_nechet, temp;
   int *ptr = arr; // объявление указателя на массив (ptr хранит адрес первого элемента)
  
   // Установка начального значения для генерации псевдослучайных чисел
   srand(time(NULL));
  
   printf("=== ARRAY PROCESSING PROGRAM (POINTERS) ===\n\n");
  
   // Определение метода ввода данных в массив
   printf("Select array filling method:\n");
   printf("1 - Keyboard input\n");
   printf("2 - Random numbers\n");
   printf("Your choice: ");
   scanf("%d", &choice);
  
   // Инициализация массива посредством указателя
   //ptr = arr; // Присвоение адреса начала массива (аналогично &arr[0])
  
   if (choice == 1)
   {
       // Режим пользовательского ввода с применением указателей
       printf("\nEnter %d numbers:\n", SIZE);
       for (i = 0; i < SIZE; i++)
       {
           printf("Number %d: ", i + 1);
           scanf("%d", ptr + i); // запись по адресу (ptr + i) соответствует &arr[i]
       }
       printf("\n");
      
       // Отображение введенных значений посредством указателей
       printf("Array address: %p\n", ptr); // вывод базового адреса массива через указатель
       printf("Original array: \n");
       for (i = 0; i < SIZE; i++)
       {
           printf("arr[%d] = %d, address: %p\n", i, *(ptr + i), ptr + i); // доступ к значению через разыменование
       }
       printf("\n");
   }
   else
   {
       // Автоматическая генерация значений с использованием указателей
       printf("Generating random numbers.......\n");
       for (i = 0; i < SIZE; i++)
       {
           *(ptr + i) = rand() % 100;  // присваивание через операцию разыменования
       }
      
       // Отображение сгенерированных данных через указатели
       printf("Array address: %p\n", ptr);
       printf("\nOriginal array: \n");
       for (i = 0; i < SIZE; i++)
       {
           printf("arr[%d] = %d, address: %p\n", i, *(ptr + i), ptr + i);
       }
   }
  
   // Завершение этапа вывода исходных данных


   // Шаг 1: Получение искомого значения от пользователя
   printf("\nEnter number A: ");
   scanf("%d", &A);
  
   // Алгоритм поиска заданного числа посредством указателей
   INC_A = -1;  // инициализация индикатора отсутствия элемента
   for (i = 0; i < SIZE; i++)
   {
       if (*(ptr + i) == A)  // сравнение через операцию разыменования
       {
           INC_A = i;  // сохранение индекса обнаруженного элемента
           break;      // прерывание итерации при успешном обнаружении
       }
   }
  
   // Шаг 2: Выполнение операций в зависимости от результата поиска
   if (INC_A != -1)
   {
       printf("Number %d found at position %d\n", A, INC_A);
      
       // Подсчет суммы элементов, следующих за найденным (через указатели)
       sum = 0;
       for (i = INC_A + 1; i < SIZE; i++) // старт с позиции, следующей за обнаруженной
       {
           sum += *(ptr + i);  // добавление значения через разыменование
       }
       printf("Sum of elements after found A: %d\n", sum);
   }
   else
   {
       printf("Number %d not found in array\n", A);
      
       // Определение наименьшего нечетного элемента с применением указателей
       char flag = 0;
       min_nechet = 1000000;
       for (i = 0; i < SIZE; i++)
       {
           if (*(ptr + i) % 2 != 0)  // проверка нечетности через разыменование
           { 
               if (*(ptr + i) < min_nechet)  // сравнение значений через указатель
               {
                   min_nechet = *(ptr + i);  // обновление минимума через разыменование
                   flag = 1;
               }
           }
       }
      
       // Анализ флага для определения наличия нечетных чисел
       if (flag == 1) 
       {
           printf("Minimum odd element: %d\n", min_nechet);   
       }
       else
       {
           printf("No odd elements\n");
       }
   }
  
   // Шаг 3: Упорядочивание массива методом "пузырька" с использованием указателей
   for (i = 0; i < SIZE - 1; i++)
   {
       for (j = 0; j < SIZE - i - 1; j++)
       {
           if (*(ptr + j) > *(ptr + j + 1))  // сопоставление соседних элементов через разыменование
           {
               // Процесс обмена значений между смежными элементами
               temp = *(ptr + j);
               *(ptr + j) = *(ptr + j + 1);
               *(ptr + j + 1) = temp;
           }
       }
   }
  
   printf("\n");
   // Отображение упорядоченного массива посредством указателей
   printf("Array address: %p\n", ptr);
   printf("Sorted array: \n");
   for (i = 0; i < SIZE; i++)
   {
       printf("arr[%d] = %d, address: %p\n", i, *(ptr + i), ptr + i);
   }
   printf("\n");
  
   return 0;
}







Тесты

Тест 1: Число A найдено в массиве
Входные данные:
Способ: 1 (клавиатура)
Массив: [20, 50, 30, 40, 10]
A: 30
Ожидаемый результат:
"Число 30 найдено на позиции 2"
Сумма после A: 50
Отсортированный: [10, 20, 30, 40, 50] 




Тест 2: Число A не найдено, есть нечетные элементы
Входные данные:
Способ: 1 (клавиатура)
Массив: [4, 9, 12, 7, 2]
A: 5
Ожидаемый результат:
"Число 5 не найдено в массиве"
Минимальный нечетный: 7
Отсортированный: [2, 4, 7, 9, 12]




Тест 3: Число A не найдено, нет нечетных элементов
Входные данные:
Способ: 1 (клавиатура)
Массив: [10, 6, 8, 4, 2]
A: 3
Ожидаемый результат:
"Число 3 не найдено в массиве"
"Нечетных элементов нет"
Отсортированный: [2, 4, 6, 8, 10]








Тест 4: Случайные числа
Входные данные:
Способ: 2 (случайные числа)
A: 50
Ожидаемый результат:
Корректная генерация чисел
Правильная обработка в зависимости от наличия A
Корректная сортировка













Тест 5: Случайные числа
Входные данные:
Способ: 2 (случайные числа)
A: 74
Ожидаемый результат:
Корректная генерация чисел
Правильная обработка в зависимости от наличия A
Корректная сортировка









 


Вывод

В рамках лабораторной работы реализовано два варианта программы обработки одномерного массива: с применением классической индексной адресации и с использованием указателей. В процессе тестирования обоих вариантов были проверены следующие операции:

- Определение позиции заданного элемента A в массиве
- Нахождение суммы всех элементов, расположенных после найденного значения
- Выявление минимального нечетного элемента в случае отсутствия искомого числа
- Упорядочивание элементов массива по возрастанию методом пузырьковой сортировки

Результаты выполнения программ при одинаковых входных данных полностью совпали. Работа с указателями показала, что данный механизм представляет собой эффективную альтернативу стандартной индексации массивов, обеспечивая эквивалентную функциональность при доступе и обработке элементов.
.

