МИНИСТЕРСТВО науки и высшего ОБРАЗОВАНИЯ РОссИЙСКОЙ ФЕДЕРАЦИИ
 
ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ
УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
«МОСКОВСКИЙ АВИАЦИОННЫЙ ИНСТИТУТ
 (национальный исследовательский университет)»
 

 
Факультет №3 «Системы управления, информатика и электроэнергетика»
Кафедра № 304 «Вычислительные машины, системы и сети»
 
 
 
 
Информатика
 
Отчет по лабораторной работе № 4
Вариант [номер варианта]
 
 
 
 
 					Выполнил студент группы: [Номер группы]
Проверили: [ФИО преподавателя]


Оглавление
Задание	3
Блок схемы алгоритмов	4
Код программы	11
Тесты	16
Вывод	19

Задание

Исследование и сравнение алгоритмов сортировки:
- сортировка обменом («пузырьковая»),
- сортировка выбором,
- сортировка вставкой.

Требования к выполнению:

1. Ввод данных:
   - Размерность массива n вводится с клавиатуры
   - Выделяется память под динамический массив из n элементов
   - Значения элементов массива генерируются с помощью функции rand()

2. Тестирование алгоритмов:
   - Сортировка случайной последовательности чисел
   - Сортировка уже отсортированной последовательности (возрастание) — лучший случай
   - Сортировка последовательности в убывающем порядке — худший случай

3. Промежуточные результаты:
   - Для массивов размерностью n = 10 выводить каждый шаг сортировки
   - На каждом шаге выводить весь массив

4. Метрики сравнения:
   - Количество необходимых сравнений
   - Количество перестановок (обменов)

5. Размерности для тестирования:
   - n = 10 (с выводом массивов)
   - n = 100 (только статистика)
   - n = 1000 (только статистика)
   - n = 10000 (только статистика)




Блок схемы алгоритмов

2.1. Пузырьковая сортировка (Bubble Sort)

```mermaid
flowchart TD
    Start([Начало]) --> Init[Инициализация:<br/>comparisons = 0<br/>swaps = 0]
    Init --> OuterLoop{i < n - 1}
    OuterLoop -->|Да| InnerInit[swapped = 0<br/>j = 0]
    InnerInit --> InnerLoop{j < n - i - 1}
    
    InnerLoop -->|Да| Compare[comparisons++<br/>Сравнить arr[j] > arr[j+1]]
    Compare -->|Да| Swap[Обмен arr[j] ↔ arr[j+1]<br/>swaps++<br/>swapped = 1]
    Compare -->|Нет| IncrJ
    Swap --> IncrJ[j++]
    IncrJ --> InnerLoop
    
    InnerLoop -->|Нет| CheckSwapped{swapped == 0?}
    CheckSwapped -->|Да| End
    CheckSwapped -->|Нет| IncrI[i++]
    IncrI --> OuterLoop
    
    OuterLoop -->|Нет| End([Конец])
```

Принцип работы: Алгоритм последовательно сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке. После каждого прохода наибольший элемент "всплывает" в конец массива.

Временная сложность:
- Лучший случай: O(n) — массив уже отсортирован
- Средний случай: O(n²)
- Худший случай: O(n²) — массив отсортирован в обратном порядке




2.2. Сортировка выбором (Selection Sort)

```mermaid
flowchart TD
    Start([Начало]) --> Init[Инициализация:<br/>comparisons = 0<br/>swaps = 0]
    Init --> OuterLoop{i < n - 1}
    OuterLoop -->|Да| FindMin[minIndex = i<br/>j = i + 1]
    
    FindMin --> InnerLoop{j < n}
    InnerLoop -->|Да| Compare[comparisons++<br/>Сравнить arr[j] < arr[minIndex]]
    Compare -->|Да| UpdateMin[minIndex = j]
    Compare -->|Нет| IncrJ
    UpdateMin --> IncrJ[j++]
    IncrJ --> InnerLoop
    
    InnerLoop -->|Нет| CheckSwap{minIndex ≠ i?}
    CheckSwap -->|Да| Swap[Обмен arr[i] ↔ arr[minIndex]<br/>swaps++]
    CheckSwap -->|Нет| IncrI
    Swap --> IncrI[i++]
    IncrI --> OuterLoop
    
    OuterLoop -->|Нет| End([Конец])
```

Принцип работы: Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом неотсортированной части. Процесс повторяется до полной сортировки.

Временная сложность:
- Лучший случай: O(n²)
- Средний случай: O(n²)
- Худший случай: O(n²)

Особенность: Количество сравнений не зависит от начального порядка элементов, но количество обменов минимально.




2.3. Сортировка вставкой (Insertion Sort)

```mermaid
flowchart TD
    Start([Начало]) --> Init[Инициализация:<br/>comparisons = 0<br/>swaps = 0]
    Init --> OuterLoop{i < n}
    OuterLoop -->|Да| SaveKey[key = arr[i]<br/>j = i - 1]
    
    SaveKey --> InnerLoop{j >= 0}
    InnerLoop -->|Да| Compare[comparisons++<br/>Сравнить arr[j] > key]
    Compare -->|Да| Shift[arr[j+1] = arr[j]<br/>swaps++<br/>j--]
    Compare -->|Нет| Insert
    Shift --> InnerLoop
    
    InnerLoop -->|Нет| Insert[arr[j+1] = key]
    Insert --> IncrI[i++]
    IncrI --> OuterLoop
    
    OuterLoop -->|Нет| End([Конец])
```

Принцип работы: Алгоритм берет элементы по одному и вставляет каждый в нужную позицию уже отсортированной части массива, сдвигая элементы при необходимости.

Временная сложность:
- Лучший случай: O(n) — массив уже отсортирован
- Средний случай: O(n²)
- Худший случай: O(n²) — массив отсортирован в обратном порядке

Особенность: Эффективен для малых массивов и почти отсортированных данных.




Код программы

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct {
    long long comparisons;
    long long swaps;
} SortStats;

// Пузырьковая сортировка
SortStats bubbleSort(int *arr, int n, int showSteps) {
    SortStats stats = {0, 0}; 
    int i, j, temp, swapped; 
    
    if (showSteps) {
        printf("Исходный массив: ");
        for (i = 0; i < n; i++) printf("%d ", arr[i]);
        printf("\n");
    }
    
    for (i = 0; i < n - 1; i++) {
        swapped = 0; 
        for (j = 0; j < n - i - 1; j++) {
            stats.comparisons++;
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                stats.swaps++;
                swapped = 1;
            }
        }
        if (showSteps) {
            printf("Шаг %d: ", i + 1);
            for (j = 0; j < n; j++) printf("%d ", arr[j]);
            printf("\n");
        }
        if (!swapped) break;
    }
    
    if (showSteps) {
        printf("Отсортированный массив: ");
        for (i = 0; i < n; i++) printf("%d ", arr[i]);
        printf("\n");
    }
    
    return stats;
}

// Сортировка выбором
SortStats selectionSort(int *arr, int n, int showSteps) { 
    SortStats stats = {0, 0};
    int i, j, minIndex, temp;
    
    if (showSteps) {
        printf("Исходный массив: ");
        for (i = 0; i < n; i++) printf("%d ", arr[i]);
        printf("\n");
    }
    
    for (i = 0; i < n - 1; i++) {
        minIndex = i;
        for (j = i + 1; j < n; j++) {
            stats.comparisons++;
            if (arr[j] < arr[minIndex]) minIndex = j;
        }
        if (minIndex != i) {
            temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
            stats.swaps++;
        }
        if (showSteps) {
            printf("Шаг %d: ", i + 1);
            for (j = 0; j < n; j++) printf("%d ", arr[j]);
            printf("\n");
        }
    }
    
    if (showSteps) {
        printf("Отсортированный массив: ");
        for (i = 0; i < n; i++) printf("%d ", arr[i]);
        printf("\n");
    }
    
    return stats;
}

// Сортировка вставкой
SortStats insertionSort(int *arr, int n, int showSteps) {
    SortStats stats = {0, 0};
    int i, j, key;
    
    if (showSteps) {
        printf("Исходный массив: ");
        for (i = 0; i < n; i++) printf("%d ", arr[i]);
        printf("\n");
    }
    
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0) {
            stats.comparisons++;
            if (arr[j] > key) {
                arr[j + 1] = arr[j];
                stats.swaps++;
                j--;
            } else {
                break;
            }
        }
        arr[j + 1] = key;
        if (showSteps) {
            printf("Шаг %d: ", i);
            for (j = 0; j < n; j++) printf("%d ", arr[j]);
            printf("\n");
        }
    }
    
    if (showSteps) {
        printf("Отсортированный массив: ");
        for (i = 0; i < n; i++) printf("%d ", arr[i]);
        printf("\n");
    }
    
    return stats;
}

// Вспомогательные функции
void copyArray(int *src, int *dst, int n) {
    int i;
    for (i = 0; i < n; i++) dst[i] = src[i];
}

void simpleSort(int *arr, int n) {
    int i, j, temp;
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void generateArrays(int *randomArr, int *sortedArr, int *reverseArr, int n) {
    int i;
    for (i = 0; i < n; i++) {
        randomArr[i] = rand() % 1000;
    }
    copyArray(randomArr, sortedArr, n);
    simpleSort(sortedArr, n);
    for (i = 0; i < n; i++) {
        reverseArr[i] = sortedArr[n - 1 - i];
    }
}

typedef SortStats (*SortFunc)(int*, int, int);

void testSort(const char *name, SortFunc sortFunc, int *src, int n, int showSteps) {
    int *arr = (int*)malloc(n * sizeof(int));
    copyArray(src, arr, n);
    
    printf("\n=== %s ===\n", name);
    SortStats stats = sortFunc(arr, n, showSteps);
    
    printf("Количество сравнений: %lld\n", stats.comparisons);
    printf("Количество перестановок: %lld\n", stats.swaps);
    
    free(arr);
}

void testSize(int n) {
    int *randomArr, *sortedArr, *reverseArr;
    int showSteps = (n == 10);
    
    randomArr = (int*)malloc(n * sizeof(int));
    sortedArr = (int*)malloc(n * sizeof(int));
    reverseArr = (int*)malloc(n * sizeof(int));
    
    generateArrays(randomArr, sortedArr, reverseArr, n);
    
    printf("\n========================================\n");
    printf("РАЗМЕР МАССИВА: %d\n", n);
    printf("========================================\n");
    
    testSort("Пузырьковая сортировка - Случайная последовательность", 
             bubbleSort, randomArr, n, showSteps);
    testSort("Пузырьковая сортировка - Отсортированная (возрастание)", 
             bubbleSort, sortedArr, n, showSteps);
    testSort("Пузырьковая сортировка - Отсортированная (убывание)", 
             bubbleSort, reverseArr, n, showSteps);
    
    testSort("Сортировка выбором - Случайная последовательность", 
             selectionSort, randomArr, n, showSteps);
    testSort("Сортировка выбором - Отсортированная (возрастание)", 
             selectionSort, sortedArr, n, showSteps);
    testSort("Сортировка выбором - Отсортированная (убывание)", 
             selectionSort, reverseArr, n, showSteps);
    
    testSort("Сортировка вставкой - Случайная последовательность", 
             insertionSort, randomArr, n, showSteps);
    testSort("Сортировка вставкой - Отсортированная (возрастание)", 
             insertionSort, sortedArr, n, showSteps);
    testSort("Сортировка вставкой - Отсортированная (убывание)", 
             insertionSort, reverseArr, n, showSteps);
    
    free(randomArr);
    free(sortedArr);
    free(reverseArr);
}

int main() {
    int n;
    srand(time(NULL)); 
    
    printf("Введите размерность массива n: ");
    scanf("%d", &n);
    
    if (n <= 0) {
        printf("Ошибка: размерность должна быть положительным числом!\n");
        return 1;
    }
    
    testSize(n);
    
    return 0;
}




Тесты

Тест 1: Размер массива n = 10

Входные данные:
n = 10
Генерируемый случайный массив: 359 783 583 620 849 146 692 843 364 567
Отсортированный массив (возрастание): 146 359 364 567 583 620 692 783 843 849
Отсортированный массив (убывание): 849 843 783 692 620 583 567 364 359 146

Ожидаемый результат:
Для каждого алгоритма получены результаты сортировки с выводом промежуточных шагов и статистики сравнений и перестановок.

Полученный результат:

Пузырьковая сортировка - Случайная последовательность:
Исходный массив: 359 783 583 620 849 146 692 843 364 567 
Шаг 1: 359 583 620 783 146 692 843 364 567 849 
Шаг 2: 359 583 620 146 692 783 364 567 843 849 
Шаг 3: 359 583 146 620 692 364 567 783 843 849 
Шаг 4: 359 146 583 620 364 567 692 783 843 849 
Шаг 5: 146 359 583 364 567 620 692 783 843 849 
Шаг 6: 146 359 364 567 583 620 692 783 843 849 
Шаг 7: 146 359 364 567 583 620 692 783 843 849 
Отсортированный массив: 146 359 364 567 583 620 692 783 843 849 
Количество сравнений: 42
Количество перестановок: 22

Пузырьковая сортировка - Отсортированная (возрастание):
Количество сравнений: 9
Количество перестановок: 0

Пузырьковая сортировка - Отсортированная (убывание):
Количество сравнений: 45
Количество перестановок: 45

Сортировка выбором - Случайная последовательность:
Количество сравнений: 45
Количество перестановок: 8

Сортировка выбором - Отсортированная (возрастание):
Количество сравнений: 45
Количество перестановок: 0

Сортировка выбором - Отсортированная (убывание):
Количество сравнений: 45
Количество перестановок: 5

Сортировка вставкой - Случайная последовательность:
Количество сравнений: 30
Количество перестановок: 22

Сортировка вставкой - Отсортированная (возрастание):
Количество сравнений: 9
Количество перестановок: 0

Сортировка вставкой - Отсортированная (убывание):
Количество сравнений: 45
Количество перестановок: 45



Тест 2: Размер массива n = 100

Входные данные:
n = 100
Тип данных: случайные числа от 0 до 999, отсортированный массив (возрастание), отсортированный массив (убывание)

Ожидаемый результат:
Корректная работа всех алгоритмов с выводом только статистики (без промежуточных шагов).

Полученный результат:

| Алгоритм | Тип последовательности | Сравнений | Перестановок |
|----------|----------------------|-----------|--------------|
| Пузырьковая | Случайная | 4740 | 2487 |
| Пузырьковая | Возрастание | 99 | 0 |
| Пузырьковая | Убывание | 4950 | 4946 |
| Выбором | Случайная | 4950 | 95 |
| Выбором | Возрастание | 4950 | 0 |
| Выбором | Убывание | 4950 | 52 |
| Вставкой | Случайная | 2583 | 2487 |
| Вставкой | Возрастание | 99 | 0 |
| Вставкой | Убывание | 4950 | 4946 |



Тест 3: Размер массива n = 1000

Входные данные:
n = 1000
Тип данных: случайные числа от 0 до 999, отсортированный массив (возрастание), отсортированный массив (убывание)

Ожидаемый результат:
Корректная работа всех алгоритмов с выводом только статистики.

Полученный результат:

| Алгоритм | Тип последовательности | Сравнений | Перестановок |
|----------|----------------------|-----------|--------------|
| Пузырьковая | Случайная | 498797 | 248412 |
| Пузырьковая | Возрастание | 999 | 0 |
| Пузырьковая | Убывание | 499500 | 499005 |
| Выбором | Случайная | 499500 | 989 |
| Выбором | Возрастание | 499500 | 0 |
| Выбором | Убывание | 499500 | 608 |
| Вставкой | Случайная | 249403 | 248412 |
| Вставкой | Возрастание | 999 | 0 |
| Вставкой | Убывание | 499382 | 499005 |



Тест 4: Размер массива n = 10000

Входные данные:
n = 10000
Тип данных: случайные числа от 0 до 999, отсортированный массив (возрастание), отсортированный массив (убывание)

Ожидаемый результат:
Корректная работа всех алгоритмов с выводом только статистики.

Полученный результат:

| Алгоритм | Тип последовательности | Сравнений | Перестановок |
|----------|----------------------|-----------|--------------|
| Пузырьковая | Случайная | 49989849 | 25063776 |
| Пузырьковая | Возрастание | 9999 | 0 |
| Пузырьковая | Убывание | 49994945 | 49945072 |
| Выбором | Случайная | 49995000 | 9984 |
| Выбором | Возрастание | 49995000 | 0 |
| Выбором | Убывание | 49995000 | 7163 |
| Вставкой | Случайная | 25073770 | 25063776 |
| Вставкой | Возрастание | 9999 | 0 |
| Вставкой | Убывание | 49954072 | 49945072 |



Вывод

В рамках лабораторной работы реализованы три классических алгоритма сортировки: пузырьковая сортировка, сортировка выбором и сортировка вставкой. В процессе тестирования были проверены следующие аспекты:

- Корректность работы алгоритмов на различных типах входных данных (случайные, отсортированные по возрастанию и убыванию)
- Подсчет количества сравнений и перестановок для каждого алгоритма
- Вывод промежуточных результатов для массивов размерностью n = 10
- Тестирование на массивах различной размерности (10, 100, 1000, 10000 элементов)

Результаты тестирования показали:

1. Пузырьковая сортировка демонстрирует отличные результаты на уже отсортированных данных (всего n-1 сравнений и 0 обменов), но наихудшую производительность на случайных и обратно отсортированных массивах.

2. Сортировка выбором имеет стабильное количество сравнений (всегда n(n-1)/2) независимо от типа данных, но минимальное количество обменов. На массиве из 10000 элементов выполнила всего 9984 обмена при случайных данных против 25 миллионов у пузырьковой сортировки.

3. Сортировка вставкой демонстрирует наилучшую производительность в среднем случае. На случайных данных выполняет примерно в 2 раза меньше сравнений, чем пузырьковая сортировка.

4. При увеличении размера массива в 10 раз количество операций увеличивается примерно в 100 раз, что подтверждает квадратичную сложность O(n²) всех трех алгоритмов.

5. Для небольших массивов (n < 100) все алгоритмы работают быстро. Для больших массивов (n > 10000) следует использовать более эффективные алгоритмы (быстрая сортировка, сортировка слиянием).

Полученные экспериментальные данные полностью соответствуют теоретическим оценкам временной сложности алгоритмов, что подтверждает корректность реализации.
